## 反射reflect

反射指的是一个对象应该具有，可以检测，修改，增加自身属性的能力。

反射就是通过字符串操作属性。

涉及的4个函数

```python
# 解释器的内置函数
hasattr    # 判断某个值是否具有某个属性 
getattr    # 从属性中获取某个值，如果没有可以设定为某个值
setattr    # 为对象设置新的属性
delattr    # 删除对象的属性
```

 使用场景

反射其实就是对属性的增删改查，但是如果直接使用内置方法__dict__来操作，语法繁琐，不好理解。

另外一个问题是，如果对象是别人提供的，我就必须判断这个对象是否满足要求，也就是是否我需要的属性和方法。

## 动态导入

```python

import importlib
# 你可以通过创建一个自定义的导入器类来扩展 importlib 的功能。这通常用于实现特定的导入逻辑，例如从非标准位置加载模块。

```

## 元类metaclass

用于创建类的类。

默认情况下所有类的元类都是type产生的。

一个类的基本组成部分：

类的名字、类的多个父类是一个元组或者列表、类的名称空间(字典类型)

学习元类的目的：

高度的自定义一个类。例如:控制一个类的名字必须以大驼峰的方式来书写。 这种方式就要修改元类，但是不推荐直接修改源码，所以通过自定义新的元类再继承再覆盖原有属性的方法来修改。

## 元类中的call方法

> 当你调用类对象时会自动珍惜元类中的__call__方法 ,并将这个类本身作为第一个参数传入,以及后面的一堆参数 覆盖元类中的call之后,这个类就无法产生对象,必须调用super().__call__来完成对象的创建并返回其返回值。

使用场景:

当你想要控制对象的创建过程时,就覆盖call方法。

当你想要控制类的创建过程时,就覆盖init方法。

注意: 一旦覆盖了call必须调用父类的call方法来产生对象并返回这个对象 


## new方法

> 当你要创建类对象时,会首先执行元类中的__new__方法,拿到一个空对象,然后会自动调用__init__来对这个类进行初始化操作.
> 
> 注意: 如果你覆盖了该方法则必须保证,new方法必须有返回值且必须是,对应的类对象.
>

## 单例设计模式

> 设计模式?用于解决某种固定问题的套路
> 
> 例如:MVCMTV等
> 
> 单例:指的是一个类产生一个对象
> 
> 为什么要使用单例:单例是为了节省 资源,当一个类的所有对象属性全部相同时,则没有必要创建多个对象。
> 
> 比如: 有一百个学生，都属于Persion类，不肯呢个去创建100个对象。