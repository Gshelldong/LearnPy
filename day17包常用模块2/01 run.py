import md
import os
import sys


BASE_DIR = os.path.dirname(__file__)
sys.path.append(BASE_DIR)

md.f1()
md.f2()
md.f3()

# coding:utf-8
"""
模块
    三种来源
        1.内置的
        2.第三方的
        3.自定义的
    四种表示形式
        1.py文件(******)
        2.共享库
        3.文件夹(一系列模块的结合体)(******)
        4.C++编译的连接到python内置的
"""
# 研究模块与包 还可以站另外两个角度分析不同的问题
# 1.模块的开发者
# 2.模块的使用者

"""
导包的过程
先产生一个执行文件的名称空间
    1.创建模块文件的名称空间
    2.执行模块文件中的代码 将产生的名字放入模块的名称空间中
    3.在执行文件中拿到一个指向模块名称空间的名字
"""

"""
什么是包?
    它是一系列模块文件的结合体,表示形式就是一个文件夹
    该文件夹内部通常会有一个__init__.py文件
    包的本质还是一个模块
"""


"""
首次导入包:
    先产生一个执行文件的名称空间
        1.创建包下面的__init__.py文件的名称空间
        2.执行包下面的__init__.py文件中的代码 将产生的名字放入包下面的__init__.py文件名称空间中
        3.在执行文件中拿到一个指向包下面的__init__.py文件名称空间的名字

在导入语句中 .号的左边肯定是一个包(文件夹)

当你作为包的设计者来说
    1.当模块的功能特别多的情况下 应该分文件管理
    2.每个模块之间为了避免后期模块改名的问题 你可以使用相对导入(包里面的文件都应该是被导入的模块)

站在包的开发者 如果使用绝对路径来管理的自己的模块 那么它只需要永远以包的路径为基准依次导入模块
站在包的使用者 你必须得将包所在的那个文件夹路径添加到system path中(******)

python2如果要导入包 包下面必须要有__init__.py文件
python3如果要导入包 包下面没有__init__.py文件也不会报错
当你在删程序不必要的文件的时候 千万不要随意删除__init__.py文件

"""






